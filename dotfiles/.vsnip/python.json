{
	"InputAll": {
		"prefix": ["inputall"],
		"body": [
			"${1:n} = input()",
			"if ' ' not in ${1:n}:",
			"\tif ${1:n}.isdigit():",
			"\t\t${1:n} = int(n)",
			"\telif float(n):",
			"\t\t${1:n} = float(n)",
			"else:",
			"\t# ===== int =====",
			"\t# a, b = map(int, ${1:n}.split())",
			"\t# l = list(map(int, ${1:n}.split()))",
			"\t# ===== str =====",
			"\t# a, b = ${1:n}.split()",
			"\t# l = ${1:n}.split()",
			"\t# ===== float =====",
			"\t# a, b = map(float, ${1:n}.split())",
			"\t# l = list(map(float, ${1:n}.split()))$0"
		]
	},
	"ListMulti": {
		"prefix": ["listmulti"],
		"body": [
			"${1:ml} = [$2 for i in range($3)]"
		]
	},
	"ListMulti2d": {
		"prefix": ["listmulti2d"],
		"body": [
			"${1:ml} = [[$2 for i in range($3)] for j in range($4)]"
		]
	},
	"Filter": {
		"prefix": ["filter"],
		"body": [
			"${1:f} = list(filter(lambda el: $3, $2))$0"
		]
	},
	"Map": {
		"prefix": ["map"],
		"body": [
			"${1:m} = list(map(lambda el: $3, $2))$0"
		]
	},
	"Reduce": {
		"prefix": ["reduce"],
		"body": [
			"from functools import reduce",
			"${1:r} = reduce(lambda hist,el: $3, $2)$0"
		]
	},
	"All": {
		"prefix": ["all"],
		"body": [
			"all($2 for i in $1)$0"
		]
	},
	"CombineList": {
		"prefix": ["combinelist"],
		"body": [
			"' '.join(map(str, $1))$0"
		]
	},
	"Counter": {
		"prefix": ["counter"],
		"body": [
			"from collections import Counter",
			"${1:c} = Counter($2)$0"
		]
	},
	"CounterSort": {
		"prefix": ["countersort"],
		"body": [
			"from collections import Counter",
			"${1:c} = Counter($2).most_common()$0"
		]
	},
	"Any": {
		"prefix": ["any"],
		"body": [
			"any($2 for i in $1)$0"
		]
	},
	"NotAny": {
		"prefix": ["notany"],
		"body": [
			"not any($2 for i in $1)$0"
		]
	},
	"Sum": {
		"prefix": ["sum"],
		"body": [
			"sum($2 for i in $1)$0"
		]
	},
	"SameElementInList": {
		"prefix": ["sameelementinlist"],
		"body": [
			"set($1).intersection(set($2))$0"
		]
	},
	"ForRange": {
		"prefix": ["forrange"],
		"body": [
			"for ${1:i} in range($2):",
			"\t$0"
		]
	},
	"ForEnumerate": {
		"prefix": ["forenumerate"],
		"body": [
			"for ${1:i, item} in enumerate($2):",
			"\t$0"
		]
	},
	"For": {
		"prefix": ["for"],
		"body": [
			"for ${1:i} in $2:",
			"\t$0"
		]
	},
	"Unique": {
		"prefix": ["unique"],
		"body": [
			"def unique(collection):",
			"\tresult = []",
			"\treturn [x for x in collection if x not in result and not result.append(x)]"
		]
	},
	"SumOfDigits": {
		"prefix": ["sumofdigits"],
		"body": [
			"def sum_of_digits(n):",
			"\tresult   = 0",
			"\tquotient = n",
			"\twhile quotient:",
			"\t\tresult   +=  quotient % 10,",
			"\t\tquotient //= 10",
			"\treturn result"
		]
	},
	"InputInt": {
		"prefix": ["inputint"],
		"body": [
			"${1:n} = int(input())$0"
		]
	},
	"InputIntMap": {
		"prefix": ["inputintmap"],
		"body": [
			"${1:a, b} = map(int, input().split())$0"
		]
	},
	"ReMatch": {
		"prefix": ["rematch"],
		"body": [
			"re.match('$2', $1)$0"
		]
	},
	"InputIntList": {
		"prefix": ["inputintlist"],
		"body": [
			"${1:l} = list(map(int, input().split()))$0"
		]
	},
	"InputStr": {
		"prefix": ["inputstr"],
		"body": [
			"${1:n} = input()$0"
		]
	},
	"InputStrMap": {
		"prefix": ["inputstrmap"],
		"body": [
			"${1:a, b} = input().split()$0"
		]
	},
	"InputStrList": {
		"prefix": ["inputstrlist"],
		"body": [
			"${1:l} = input().split()$0"
		]
	},
	"InputFloat": {
		"prefix": ["inputfloat"],
		"body": [
			"${1:n} = float(input())$0"
		]
	},
	"InputFloatMap": {
		"prefix": ["inputfloatmap"],
		"body": [
			"${1:a, b} = map(float, input().split()) $2"
		]
	},
	"InputFloatList": {
		"prefix": ["inputfloatlist"],
		"body": [
			"${1:l} = list(map(float, input().split()))$0"
		]
	},
	"Print": {
		"prefix": ["print"],
		"body": [
			"print($1 ${2:, flush=True})$0"
		]
	},
	"AlphabetNth": {
		"prefix": ["alphabetnth"],
		"body": [
			"${1:s} = [chr(ord('a') + i) for i in range(${2:10})]$0"
		]
	},
	"Def": {
		"prefix": ["def"],
		"body": [
			"def ${1:defname}($2):",
			"\t$0"
		]
	},
	"Len": {
		"prefix": ["len"],
		"body": [
			"len($1)$0"
		]
	},
	"While": {
		"prefix": ["while"],
		"body": [
			"while $1:",
			"\t$0"
		]
	},
	"If": {
		"prefix": ["if"],
		"body": [
			"if $1:",
			"\t$0"
		]
	},
	"Ifelif": {
		"prefix": ["ifelif"],
		"body": [
			"if $1:",
			"\t$0",
			"elif $2:",
			"\t",
			"else:",
			"\t"
		]
	},
	"Ifelse": {
		"prefix": ["ifelse"],
		"body": [
			"if $1:",
			"\t$0",
			"else:"
		]
	},
	"ReplaceWithRegex": {
		"prefix": ["replacewithregex"],
		"body": [
			"import re",
			"str = re.sub(r'$1', '$2', $3)$0"
		]
	},
	"Round": {
		"prefix": ["round"],
		"body": [
			"def round(n, digit=0):",
			"\tif digit < 0:",
			"\t\timport sys",
			"\t\tsys.stderr.write('Error: digit must be positive')",
			"\t\texit()",
			"\tp = 10**digit",
			"\tans = (n*p*2+1) // 2 / p",
			"\tif digit == 0:",
			"\t\tans = int(ans)",
			"\treturn ans"
		]
	},
	"GcdLcm": {
		"prefix": ["gcdlcm"],
		"body": [
			"def gcd(a, b):",
			"\twhile b != 0:",
			"\t\ta, b = b, a % b",
			"\treturn a",
			"def lcm(a, b):",
			"\treturn a * b // gcd(a, b)"
		]
	},
	"CumulativeSum": {
		"prefix": ["cumulativesum"],
		"body": [
			"def cumulative_sum(collection):",
			"\tresult = [0]",
			"\tfor item in collection:",
			"\t\tresult.append(result[-1] + item)",
			"\treturn result"
		]
	},
	"CumulativeSum2d": {
		"prefix": ["cumulativesum2d"],
		"body": [
			"class CumulativeSum2d():",
			"\tdef __init__(self, collection_2d):",
			"\t\tyl = len(collection_2d)",
			"\t\txl = len(collection_2d[0])",
			"\t\tself.data = [[0] * (xl+1) for _ in range(yl+1)]",
			"\t\tfor y in range(1, yl+1):",
			"\t\t\tfor x in range(1, xl+1):",
			"\t\t\t\ttop_sum         = self.data[y-1][x]",
			"\t\t\t\tleft_sum        = self.data[y][x-1]",
			"\t\t\t\tdup_sum         = self.data[y-1][x-1]",
			"\t\t\t\tself.data[y][x] = top_sum + left_sum - dup_sum",
			"\t\t\t\tself.data[y][x] += collection_2d[y-1][x-1]",
			"",
			"\tdef query(self, x, y, x1, y1):",
			"\t\treturn self.data[y1][x1] - self.data[y-1][x1] - self.data[y1][x-1] + self.data[y-1][x-1]"
		]
	},
	"Combination": {
		"prefix": ["combination"],
		"body": [
			"def combination(items_num, pair_num):",
			"\tif items_num < pair_num: return 0",
			"\tif items_num - pair_num < pair_num: pair_num = items_num - pair_num",
			"\tif pair_num == 0: return 1",
			"\tif pair_num == 1: return items_num",
			"\tnumerator   = [items_num - pair_num + k + 1 for k in range(pair_num)]",
			"\tdenominator = [k + 1 for k in range(pair_num)]",
			"\tfor p in range(2, pair_num+1):",
			"\t\tpivot = denominator[p - 1]",
			"\t\tif pivot > 1:",
			"\t\t\toffset = (items_num - pair_num) % p",
			"\t\t\tfor k in range(p-1, pair_num, p):",
			"\t\t\t\tnumerator[k - offset] /= pivot",
			"\t\t\t\tdenominator[k] /= pivot",
			"\tresult = 1",
			"\tfor k in range(pair_num):",
			"\t\tif numerator[k] > 1:",
			"\t\t\tresult *= int(numerator[k])",
			"\treturn result"
		]
	},
	"Comb": {
		"prefix": ["comb"],
		"body": [
			"from scipy.special import comb",
			"${1:c} = int(comb($2, $3))"
		]
	},
	"SieveOfEratosthenes": {
		"prefix": ["sieveoferatosthenes"],
		"body": [
			"def sieve_of_eratosthenes(n):",
			"\tprime = [2]",
			"\tlimit = int(n**0.5)",
			"\tdata = [i + 1 for i in range(2, n, 2)]",
			"\twhile True:",
			"\t\tp = data[0]",
			"\t\tif limit < p:",
			"\t\t\treturn prime + data",
			"\t\tprime.append(p)",
			"\t\tdata = [e for e in data if e % p != 0]"
		]
	},
	"UnionFind": {
		"prefix": ["unionfind"],
		"body": [
			"class UnionFind():",
			"\tdef __init__(self, n):",
			"\t\t# size of n.",
			"\t\tself.n = n",
			"\t\t# n's parent. default is -1.",
			"\t\tself.parents = [-1] * n",
			"",
			"\tdef find_root(self, x):",
			"\t\tif self.parents[x] < 0:",
			"\t\t\treturn x",
			"\t\telse:",
			"\t\t\tself.parents[x] = self.find_root(self.parents[x])",
			"\t\t\treturn self.parents[x]",
			"",
			"\tdef union_merge(self, x, y):",
			"\t\tx = self.find_root(x)",
			"\t\ty = self.find_root(y)",
			"\t\tif x == y:",
			"\t\t\treturn",
			"\t\tif self.parents[x] > self.parents[y]:",
			"\t\t\tx, y = y, x",
			"\t\tself.parents[x] += self.parents[y]",
			"\t\tself.parents[y] = x",
			"",
			"\t# You shouldn't use these below for optimization.",
			"\t# Use only find_root to compare if you need.",
			"\tdef union_size(self, x):",
			"\t\t# Root value's index has its size with negative.",
			"\t\treturn -self.parents[self.find_root(x)]",
			"",
			"\tdef is_same_union(self, x, y):",
			"\t\treturn self.find_root(x) == self.find_root(y)",
			"",
			"\tdef same_union_members(self, x):",
			"\t\troot = self.find_root(x)",
			"\t\treturn [i for i in range(self.n) if self.find_root(i) == root]",
			"",
			"\tdef roots(self):",
			"\t\treturn [i for i, x in enumerate(self.parents) if x < 0]",
			"",
			"\tdef union_count(self):",
			"\t\treturn len(self.roots())",
			"",
			"\tdef all_unions(self):",
			"\t\treturn [self.same_union_members(r) for r in self.roots()]"
		]
	},
	"Quicksort": {
		"prefix": ["quicksort"],
		"body": [
			"def quicksort(l):",
			"\tif len(l) <= 1:",
			"\t\treturn l",
   			"\tpivot = l.pop()",
   			"\tgreater, lesser = [], []",
   			"\tfor el in l:",
   			"\t\tif el > pivot:",
   			"\t\t\tgreater.append(el)",
   			"\t\telse:",
   			"\t\t\tlesser.append(el)",
   			"\treturn quicksort(lesser) + [pivot] + quicksort(greater)"
		]
	},
	"Mergesort": {
		"prefix": ["mergesort"],
		"body": [
			"def mergesort(l):",
			"\tdef merge(left, right):",
			"\t\tresult = []",
			"\t\twhile left and right:",
			"\t\t\tif left[0] <= right[0]:",
			"\t\t\t\tresult.append(left.pop(0))",
			"\t\t\telse:",
			"\t\t\t\tresult.append(right.pop(0))",
			"\t\treturn result + left + right",
			"",
			"\tlength = len(l)",
			"\tif length <= 1:",
			"\t\treturn l",
			"\tmiddle = length // 2",
			"\treturn merge(mergesort(l[:middle]), mergesort(l[middle:]))"
		]
	},
	"MergeInsertionSort": {
		"prefix": ["mergeinsertionsort"],
		"body": [
			"def merge_insertion_sort(collection):",
			"\tdef binary_search_insertion(sorted_list, item):",
			"\t\tleft = 0",
			"\t\tright = len(sorted_list) - 1",
			"\t\twhile left <= right:",
			"\t\t\tmiddle = (left + right) // 2",
			"\t\t\tif left == right:",
			"\t\t\t\tif sorted_list[middle] < item:",
			"\t\t\t\t\tleft = middle + 1",
			"\t\t\t\t\tbreak;",
			"\t\t\t\telse:",
			"\t\t\t\t\tbreak;",
			"\t\t\telif sorted_list[middle] < item:",
			"\t\t\t\tleft = middle + 1",
			"\t\t\telse:",
			"\t\t\t\tright = middle - 1",
			"\t\tsorted_list.insert(left, item)",
			"\t\treturn sorted_list",
			"",
			"\tdef sortlist_2d(list_2d):",
			"\t\tdef merge(left, right):",
			"\t\t\tresult = []",
			"\t\t\twhile left and right:",
			"\t\t\t\tif left[0][0] < right[0][0]:",
			"\t\t\t\t\tresult.append(left.pop(0))",
			"\t\t\t\telse:",
			"\t\t\t\t\tresult.append(right.pop(0))",
			"\t\t\treturn result + left + right",
			"",
			"\t\tlength = len(list_2d)",
			"\t\tif length <= 1:",
			"\t\t\treturn list_2d",
			"\t\tmiddle = length // 2",
			"\t\treturn merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))",
			"",
			"\tif len(collection) <= 1:",
			"\t\treturn collection",
			"",
			"\ttwo_paired_list = []",
			"\tis_surplus      = False",
			"\tfor i in range(0, len(collection), 2):",
			"\t\tif (i == len(collection) - 1):",
			"\t\t\tis_surplus = True",
			"\t\telse:",
			"\t\t\tif collection[i] < collection[i+1]:",
			"\t\t\t\ttwo_paired_list.append([collection[i], collection[i+1]])",
			"\t\t\telse:",
			"\t\t\t\ttwo_paired_list.append([collection[i+1], collection[i]])",
			"\tsorted_list_2d = sortlist_2d(two_paired_list)",
			"\tresult = [i[0] for i in sorted_list_2d]",
			"\tresult.append(sorted_list_2d[-1][1])",
			"",
			"\tif is_surplus:",
			"\t\tpivot = collection[-1]",
			"\t\tresult = binary_search_insertion(result, pivot)",
			"",
			"\tis_surplus_inserted_before_this_index = False",
			"\tfor i in range(len(sorted_list_2d) - 1):",
			"\t\tif result[i] == collection[-i]:",
			"\t\t\tis_surplus_inserted_before_this_index = True",
			"\t\tpivot = sorted_list_2d[i][1]",
			"\t\tif is_surplus_inserted_before_this_index:",
			"\t\t\tresult = result[:i+2] + binary_search_insertion(result[i+2:], pivot)",
			"\t\telse:",
			"\t\t\tresult = result[:i+1] + binary_search_insertion(result[i+1:], pivot)",
			"",
			"\treturn result"
		]
	}
}
