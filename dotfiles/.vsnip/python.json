{
	"InputAll": {
		"prefix": ["inputall"],
		"body": [
			"${1:I} = input()",
			"if ' ' not in ${1:I}:",
			"\tif ${1:I}.isdigit():",
			"\t\t${1:I} = int(I)",
			"\telif float(I):",
			"\t\t${1:I} = float(I)",
			"else:",
			"\t# ===== int =====",
			"\t# A, B = map(int, ${1:I}.split())",
			"\t# L = list(map(int, ${1:I}.split()))",
			"\t# ===== str =====",
			"\t# A, B = ${1:I}.split()",
			"\t# L = ${1:I}.split()",
			"\t# ===== float =====",
			"\t# A, B = map(float, ${1:I}.split())",
			"\t# L = list(map(float, ${1:I}.split()))$0"
		]
	},
	"Filter": {
		"prefix": ["filter"],
		"body": [
			"${1:F} = list(filter(lambda el: $3, $2))$0"
		]
	},
	"Map": {
		"prefix": ["map"],
		"body": [
			"${1:M} = list(map(lambda el: $3, $2))$0"
		]
	},
	"Reduce": {
		"prefix": ["reduce"],
		"body": [
			"from functools import reduce",
			"${1:R} = reduce(lambda hist,el: $3, $2)$0"
		]
	},
	"All": {
		"prefix": ["all"],
		"body": [
			"all($2 for i in $1)$0"
		]
	},
	"CombineList": {
		"prefix": ["combinelist"],
		"body": [
			"' '.join(map(str, $1))$0"
		]
	},
	"Counter": {
		"prefix": ["counter"],
		"body": [
			"from collections import Counter$0"
		]
	},
	"Any": {
		"prefix": ["any"],
		"body": [
			"any($2 for i in $1)$0"
		]
	},
	"NotAny": {
		"prefix": ["notany"],
		"body": [
			"not any($2 for i in $1)$0"
		]
	},
	"Sum": {
		"prefix": ["sum"],
		"body": [
			"sum($2 for i in $1)$0"
		]
	},
	"SameElementInList": {
		"prefix": ["sameelementinlist"],
		"body": [
			"set($1).intersection(set($2))$0"
		]
	},
	"ForRange": {
		"prefix": ["forrange"],
		"body": [
			"for ${1:i} in range($2):",
			"\t$0"
		]
	},
	"For": {
		"prefix": ["for"],
		"body": [
			"for ${1:i} in $2:",
			"\t$0"
		]
	},
	"Unique": {
		"prefix": ["unique"],
		"body": [
			"def unique(collection):",
			"\tresult = []",
			"\treturn [x for x in collection if x not in result and not result.append(x)]"
		]
	},
	"SumOfDigits": {
		"prefix": ["sumofdigits"],
		"body": [
			"def sum_of_digits(n):",
			"\tresult   = 0",
			"\tquotient = n",
			"\twhile quotient:",
			"\t\tresult   +=  quotient % 10,",
			"\t\tquotient //= 10",
			"\treturn result"
		]
	},
	"InputInt": {
		"prefix": ["inputint"],
		"body": [
			"${1:I} = int(input())$0"
		]
	},
	"InputIntMap": {
		"prefix": ["inputintmap"],
		"body": [
			"${1:A, B} = map(int, input().split())$0"
		]
	},
	"ReMatch": {
		"prefix": ["rematch"],
		"body": [
			"re.match('$2', $1)$0"
		]
	},
	"InputIntList": {
		"prefix": ["inputintlist"],
		"body": [
			"${1:L} = list(map(int, input().split()))$0"
		]
	},
	"InputStr": {
		"prefix": ["inputstr"],
		"body": [
			"${1:I} = input()$0"
		]
	},
	"InputStrMap": {
		"prefix": ["inputstrmap"],
		"body": [
			"${1:A, B} = input().split()$0"
		]
	},
	"InputStrList": {
		"prefix": ["inputstrlist"],
		"body": [
			"${1:L} = input().split()$0"
		]
	},
	"InputFloat": {
		"prefix": ["inputfloat"],
		"body": [
			"${1:I} = float(input())$0"
		]
	},
	"InputFloatMap": {
		"prefix": ["inputfloatmap"],
		"body": [
			"${1:A, B} = map(float, input().split()) $2"
		]
	},
	"InputFloatList": {
		"prefix": ["inputfloatlist"],
		"body": [
			"${1:L} = list(map(float, input().split()))$0"
		]
	},
	"Print": {
		"prefix": ["print"],
		"body": [
			"print($1${2:, flush=True})$0"
		]
	},
	"AlphabetNth": {
		"prefix": ["alphabetnth"],
		"body": [
			"${1:S} = [chr(ord('a') + i) for i in range(${2:10})]$0"
		]
	},
	"Def": {
		"prefix": ["def"],
		"body": [
			"def ${1:defname}($2):",
			"\t$0"
		]
	},
	"Len": {
		"prefix": ["len"],
		"body": [
			"len($1)$0"
		]
	},
	"While": {
		"prefix": ["while"],
		"body": [
			"while $1:",
			"\t$0"
		]
	},
	"If": {
		"prefix": ["if"],
		"body": [
			"if $1:",
			"\t$0"
		]
	},
	"Ifelse": {
		"prefix": ["ifelse"],
		"body": [
			"if $1:",
			"\t$0",
			"elif $2:",
			"\t",
			"else:",
			"\t"
		]
	},
	"UnionFind": {
		"prefix": ["unionfind"],
		"body": [
			"class UnionFind():",
			"\tdef __init__(self, n):",
			"\t\t# size of n.",
			"\t\tself.n = n",
			"\t\t# n's parent. default is -1.",
			"\t\tself.parents = [-1] * n",
			"",
			"\tdef find_root(self, x):",
			"\t\tif self.parents[x] < 0:",
			"\t\t\treturn x",
			"\t\telse:",
			"\t\t\tself.parents[x] = self.find_root(self.parents[x])",
			"\t\t\treturn self.parents[x]",
			"",
			"\tdef union_merge(self, x, y):",
			"\t\tx = self.find_root(x)",
			"\t\ty = self.find_root(y)",
			"\t\tif x == y:",
			"\t\t\treturn",
			"\t\tif self.parents[x] > self.parents[y]:",
			"\t\t\tx, y = y, x",
			"\t\tself.parents[x] += self.parents[y]",
			"\t\tself.parents[y] = x",
			"",
			"\t# You shouldn't use these below for optimization.",
			"\t# Use only find_root to compare if you need.",
			"\tdef union_size(self, x):",
			"\t\t# Root value's index has its size with negative.",
			"\t\treturn -self.parents[self.find_root(x)]",
			"",
			"\tdef is_same_union(self, x, y):",
			"\t\treturn self.find_root(x) == self.find_root(y)",
			"",
			"\tdef same_union_members(self, x):",
			"\t\troot = self.find_root(x)",
			"\t\treturn [i for i in range(self.n) if self.find_root(i) == root]",
			"",
			"\tdef roots(self):",
			"\t\treturn [i for i, x in enumerate(self.parents) if x < 0]",
			"",
			"\tdef union_count(self):",
			"\t\treturn len(self.roots())",
			"",
			"\tdef all_unions(self):",
			"\t\treturn [self.same_union_members(r) for r in self.roots()]"
		]
	},
	"Quicksort": {
		"prefix": ["quicksort"],
		"body": [
			"def quicksort(l):",
			"\tif len(l) <= 1:",
			"\t\treturn l",
   			"\tpivot = l.pop()",
   			"\tgreater, lesser = [], []",
   			"\tfor el in l:",
   			"\t\tif el > pivot:",
   			"\t\t\tgreater.append(el)",
   			"\t\telse:",
   			"\t\t\tlesser.append(el)",
   			"\treturn quicksort(lesser) + [pivot] + quicksort(greater)"
		]
	},
	"Mergesort": {
		"prefix": ["mergesort"],
		"body": [
			"def mergesort(l):",
			"\tdef merge(left, right):",
			"\t\tresult = []",
			"\t\twhile left and right:",
			"\t\t\tif left[0] <= right[0]:",
			"\t\t\t\tresult.append(left.pop(0))",
			"\t\t\telse:",
			"\t\t\t\tresult.append(right.pop(0))",
			"\t\treturn result + left + right",
			"",
			"\tlength = len(l)",
			"\tif length <= 1:",
			"\t\treturn l",
			"\tmiddle = length // 2",
			"\treturn merge(mergesort(l[:middle]), mergesort(l[middle:]))"
		]
	},
	"MergeInsertionSort": {
		"prefix": ["mergeinsertionsort"],
		"body": [
			"def merge_insertion_sort(collection):",
			"\tdef binary_search_insertion(sorted_list, item):",
			"\t\tleft = 0",
			"\t\tright = len(sorted_list) - 1",
			"\t\twhile left <= right:",
			"\t\t\tmiddle = (left + right) // 2",
			"\t\t\tif left == right:",
			"\t\t\t\tif sorted_list[middle] < item:",
			"\t\t\t\t\tleft = middle + 1",
			"\t\t\t\t\tbreak;",
			"\t\t\t\telse:",
			"\t\t\t\t\tbreak;",
			"\t\t\telif sorted_list[middle] < item:",
			"\t\t\t\tleft = middle + 1",
			"\t\t\telse:",
			"\t\t\t\tright = middle - 1",
			"\t\tsorted_list.insert(left, item)",
			"\t\treturn sorted_list",
			"",
			"\tdef sortlist_2d(list_2d):",
			"\t\tdef merge(left, right):",
			"\t\t\tresult = []",
			"\t\t\twhile left and right:",
			"\t\t\t\tif left[0][0] < right[0][0]:",
			"\t\t\t\t\tresult.append(left.pop(0))",
			"\t\t\t\telse:",
			"\t\t\t\t\tresult.append(right.pop(0))",
			"\t\t\treturn result + left + right",
			"",
			"\t\tlength = len(list_2d)",
			"\t\tif length <= 1:",
			"\t\t\treturn list_2d",
			"\t\tmiddle = length // 2",
			"\t\treturn merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))",
			"",
			"\tif len(collection) <= 1:",
			"\t\treturn collection",
			"",
			"\ttwo_paired_list = []",
			"\tis_surplus      = False",
			"\tfor i in range(0, len(collection), 2):",
			"\t\tif (i == len(collection) - 1):",
			"\t\t\tis_surplus = True",
			"\t\telse:",
			"\t\t\tif collection[i] < collection[i+1]:",
			"\t\t\t\ttwo_paired_list.append([collection[i], collection[i+1]])",
			"\t\t\telse:",
			"\t\t\t\ttwo_paired_list.append([collection[i+1], collection[i]])",
			"\tsorted_list_2d = sortlist_2d(two_paired_list)",
			"\tresult = [i[0] for i in sorted_list_2d]",
			"\tresult.append(sorted_list_2d[-1][1])",
			"",
			"\tif is_surplus:",
			"\t\tpivot = collection[-1]",
			"\t\tresult = binary_search_insertion(result, pivot)",
			"",
			"\tis_surplus_inserted_before_this_index = False",
			"\tfor i in range(len(sorted_list_2d) - 1):",
			"\t\tif result[i] == collection[-i]:",
			"\t\t\tis_surplus_inserted_before_this_index = True",
			"\t\tpivot = sorted_list_2d[i][1]",
			"\t\tif is_surplus_inserted_before_this_index:",
			"\t\t\tresult = result[:i+2] + binary_search_insertion(result[i+2:], pivot)",
			"\t\telse:",
			"\t\t\tresult = result[:i+1] + binary_search_insertion(result[i+1:], pivot)",
			"",
			"\treturn result"
		]
	}
}
