{
    "temp": {
        "prefix": "temp",
        "body": [
            "package main",
            "",
            "func main() {",
            "",
            "}",
        ],
    },
    "arg": {
        "prefix": "arg",
        "body": [
            "$1 := $2",
        ],
    },
    "log": {
        "prefix": "log",
        "body": [
            "log.Println($1)",
        ],
    },
    "logf": {
        "prefix": "logf",
        "body": [
            "log.Fatalln($1)",
        ],
    },
    "print": {
        "prefix": "print",
        "body": [
            "fmt.Println($1)",
        ],
    },
    "printf": {
        "prefix": "printf",
        "body": [
            "fmt.Printf(\"%T\\n\", $1)",
        ],
    },
    "sprintf": {
        "prefix": "sprintf",
        "body": [
            "fmt.Sprintf(\"%v\", $1)",
        ],
    },
    "replace": {
        "prefix": "replace",
        "body": [
            "strings.Replace(${1: var}, ${2: target}, ${3: replace}, ${4: index})",
        ],
        "description": "replace"
    },
    "contain": {
        "prefix": "contain",
        "body": [
            "strings.Contains(${1: var}, ${2: target})",
        ],
        "description": "contain"
    },
    "inttostr": {
        "prefix": "inttostr",
        "body": [
            "strconv.Atoi(${1: var})",
        ],
        "description": "inttostr"
    },
    "make": {
        "prefix": "make",
        "body": [
            "make([]int, ${1: num}, ${2: cap})",
        ],
        "description": "make"
    },
    "map": {
        "prefix": "map",
        "body": [
            "map[${1: type}]${2: type} {${3: value}}",
        ],
        "description": "map"
    },
    "range": {
        "prefix": "range",
        "body": [
            "for ${1: index}, ${2: arg} := range ${3: target} {",
            "    ${4: value}",
            "}",
        ]
    },
    "array": {
        "prefix": "array",
        "body": [
            "l := []int{1, 2, 5}",
        ]
    },
    "dynamic_array": {
        "prefix": "dynamic_array",
        "body": [
            "func foo(params ...int) {",
            "}",
            "func main() {",
            "   s := []int{1,2,3}",
            "   foo(s...)",
            "}",
        ]
    },
    "closure_example": {
        "prefix": "closure",
        "body": [
            "Just showing that like define const and give args func inside func",
            "func circleArea(pi float64) func(radius float64) float64 {",
            "   return func(radius float64) float64 {",
            "       return pi * radius * radius",
            "    }",
            "}",
            "",
            "func main() {",
            "   c1 := circleArea(3.14)",
            "   fmt.Println(c1(2))",
            "}",
        ]
    },
    "open": {
        "prefix": "open",
        "body": [
            "file, _ := os.Open(\"${1: arg}\")",
            "defer file.Close()",
            "data := make([]byte, 100)",
            "file.Read(data)",
            "fmt.Println(string(data))"
        ]
    },
    "logsetting": {
        "prefix": "logsetting",
        "body": [
            "func LoggingSettings(logFile string) {",
            "   logfile, _ := os.OpenFile(logFile, os.O_RDWR|os.O_CREATE|os.O_APPEND,",
            "    0666)",
            "   multiLogFIle := io.MultiWriter(os.Stdout, logfile)",
            "   log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)",
            "   log.SetOutput(multiLogFIle)",
            "}",
            "",
            "func main() {",
            "   LoggingSettings(\"test.log\")",
            "   log.Println(\"aaa\")",
            "}",
        ]
    },
    "error": {
        "prefix": "error",
        "body": [
            "if err != nil {",
            "    log.Fatal(\"Error\")",
            "}",
        ]
    },
    "panic": {
        "prefix": "panic",
        "body": [
            "defer func() {",
            "   s := recover()",
            "   fmt.Println(s)",
            "}()",
            "panic(\"unable to find\")",
        ]
    },
    "min": {
        "prefix": "min",
        "body": [
            "min := l[0]",
            "for _, arg := range l {",
            "   if arg < min {",
            "       min = arg",
            "   }",
            "}",
        ]
    },
    "switch": {
        "prefix": "switch",
        "body": [
            "switch ${1: arg} {",
            "   case:${2: condition}",
            "       ${3: process}",
            "   default:",
            "       ${4: process}",
            "}",
        ]
    },
    "asserttype": {
        "prefix": "asserttype",
        "body": [
            "switch v := i.(type) {",
            "   case:${2: condition}",
            "       ${3: process}",
            "   default:",
            "       ${4: process}",
            "}",
        ]
    },
    "waitgroup": {
        "prefix": "waitgroup",
        "body": [
            "var wg sync.WaitGroup",
        ]
    },
    "select": {
        "prefix": "select",
        "body": [
            "select {",
            "case ${1: arg} := <-${2: channel}:",
            "   ${3: process}",
            "}",
        ]
    },
    "sleep": {
        "prefix": "sleep",
        "body": [
            "time.Sleep(${1: second} * time.Second)"
        ]
    },
    "test": {
        "prefix": "test",
        "body": [
            "func Test(t *testing.T) {",
            "   t.Error(\"error\")",
            "}",
        ]
    },
    "matchstring": {
        "prefix": "matchstring",
        "body": [
            "match, _ := regexp.MatchString(\"${1: pattern}\", \"${2: arg}\")",
        ]
    },
    "mustcompile": {
        "prefix": "mustcompile",
        "body": [
            "match, _ := regexp.MustCompile(\"${1: pattern}\")",
        ]
    },
    "matchstringword": {
        "prefix": "matchstringword",
        "body": [
            "fs := r.MatchString(\"${1: arg}\")",
        ]
    },
    "findstring": {
        "prefix": "findstring",
        "body": [
            "fs := r.FindString(\"${1: pattern}\")",
        ]
    },
    "findstringsubmatch": {
        "prefix": "findstringsubmatch",
        "body": [
            "fss := r.FindStringSubmatch(\"${1: pattern}\")",
        ]
    },
    "sortint": {
        "prefix": "sortint",
        "body": [
            "sort.Ints(${1: array})",
        ]
    },
    "sortstring": {
        "prefix": "sortstring",
        "body": [
            "sort.Strings(${1: array})",
        ]
    },
    "sortstruct": {
        "prefix": "sortstruct",
        "body": [
            "sort.Slice(${1: struct}, func(i, j int) bool { return ${1: struct}[i].Name < ${1: struct}[j].Name })",
        ]
    },
    "contextcancel": {
        "prefix": "contextcancel",
        "body": [
            "ctx := context.Background()",
            "ctx, cancel := context.WithTimeout(ctx,3*time.Second)",
            "defer cancel()",
            "// pass arg as ctx context.Context, and case<-ctx.Done()"
        ]
    },
    "readfile": {
        "prefix": "readfile",
        "body": [
            "content, err := ioutil.ReadFile(\"main.go\")",
            "if err != nil {",
            "   log.Fatal(err)",
            "}",
            "fmt.Println(string(content))",
        ]
    },
    "writefile": {
        "prefix": "writefile",
        "body": [
            "err := ioutil.WriteFile(\"ioutil_temp.go\", content, 0666)",
            "if err != nil {",
            "   log.Fatalln(err)",
            "}",
        ]
    },
    "httpget": {
        "prefix": "httpget",
        "body": [
            "resp, _ := http.Get(\"http://example.com\")",
            "defer resp.Body.Close()",
            "body, _ := ioutil.ReadAll(resp.Body)",
        ]
    },
    "urlparse": {
        "prefix": "urlparse",
        "body": [
            "${1: arg},_ := url.Parse(\"${2: url}\")"
        ]
    },
    "httpreq": {
        "prefix": "httpreq",
        "body": [
            "req, _ := http.NewRequest(\"GET\", ${1: url}, nil)",
            "var client *http.Client = &http.Client{}",
            "resp, _ := client.Do(req)",
            "body, _ := ioutil.ReadAll(resp.Body)",
            "fmt.Println(string(body))",
        ]
    },
    "jsonreceive": {
        "prefix": "jsonreceive",
        "body": [
            "json.Unmarshal(${1: json}, &${2: struct})"
        ]
    },
    "jsonmake": {
        "prefix": "jsonmake",
        "body": [
            "json.Marshal(${1: struct})"
        ]
    },
    "hmacnew": {
        "prefix": "hmacnew",
        "body": [
            "h := hmac.New(sha256.New,[]byte(apiSecret)) // make hash",
            "h.Write([]byte(\"data\")) // pass data",
            "sign := hex.EncodeToString(h.Sum(nil))",
        ]
    },
    "semaphore": {
        "prefix": "semaphore",
        "body": [
            "var s *semaphore.Weighted = semaphore.NewWeighted(1)",
        ]
    },
    "type": {
        "prefix": "type",
        "body": [
            "type ${1: typename} struct {",
            "   ${2: value}",
            "}",
        ]
    },
    "ini": {
        "prefix": "ini",
        "body": [
            "func init() {",
            "   cfg, _ := ini.Load(\"${1: ininame}\")",
            "   Config = ConfigList{",
            "       Port: cfg.Section(\"${1: table}\").Key(\"${1: key}\").MustInt(),",
            "    }",
            "}",
        ]
    },
    "sqlite": {
        "prefix": "sqlte",
        "body": [
            "_ \"github.com/mattn/go-sqlite3\""
        ]
    },
    "dbput": {
        "prefix": "dbput",
        "body": [
            "var DbConnection *sql.DB",
            "",
            "func main() {",
            "   DbConnection, _ := sql.Open(\"sqlite3\", \"./example.sql\")",
            "   defer DbConnection.Close()",
            "   cmd := `CREATE TABLE IF NOT EXISTS person(",
            "                name STRING,",
            "                age INT)`",
            "   _, err := DbConnection.Exec(cmd)",
            "   if err != nil {",
            "       log.Fatal(\"Error\")",
            "    }",
            "}",
        ]
    },
    "dbget": {
        "prefix": "dbget",
        "body": [
            "var DbConnection *sql.DB",
            "",
            "func main() {",
            "   DbConnection, _ := sql.Open(\"sqlite3\", \"./example.sql\")",
            "   defer DbConnection.Close()",
            "",
            "   cmd = \"SELECT * FROM person\"",
            "   rows, _ := DbConnection.Query(cmd)",
            "   defer rows.Close()",
            "   var pp []Person",
            "   for rows.Next() {",
            "       var p Person",
            "       err := rows.Scan(&p.Name, &p.Age)",
            "       if err != nil {",
            "           log.Fatal(\"Error\")",
            "       }",
            "       pp = append(pp, p)",
            "   }",
            "   for _, p := range pp {",
            "       fmt.Println(p.Name, p.Age)",
            "    }",
            "}",
        ]
    },
    "httpserve": {
        "prefix": "httpserve",
        "body": [
            "log.Fatal(http.ListenAndServe(\": 8080\", nil))"
        ]
    },
    "httphandler": {
        "prefix": "httphandler",
        "body": [
            "http.HandleFunc(\"/${1: slug}/\", ${2: hundlefunc})"
        ]
    },
    "httphandlefunc": {
        "prefix": "httphandlefunc",
        "body": [
            "func viewHandler(w http.ResponseWriter, r *http.Request) {",
            "   title := r.URL.Path[len(\"/view/\"):]",
            "   p, _ := loadPage(title)",
            "   fmt.Fprintf(w, \"<h1>%s</h1><div>%s</div>\", p.Title, p.Body)",
            "}",
        ]
    },
    "writeresponse": {
        "prefix": "writeresponse",
        "body": [
            "fmt.Fprintf(w, \"<h1>%s</h1><div>%s</div>\", p.Title, p.Body)",
        ]
    },
}
